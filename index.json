[{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/","section":"Anza Labs","summary":"","title":"Anza Labs","type":"page"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/series/container-object-storage-interface/","section":"Series","summary":"","title":"Container Object Storage Interface","type":"series"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/container-object-storage-interface/","section":"Tags","summary":"","title":"Container Object Storage Interface","type":"tags"},{"content":"The Container Object Storage Interface (COSI) is a Kubernetes-native standard for managing object storage buckets and credentials. By abstracting provider-specific details, COSI enables dynamic provisioning, secure access management, and seamless integration with applications. In this guide, weâ€™ll deploy COSI on a Kubernetes cluster, configure a Linode driver, and deploy a sample app that leverages automated object storage workflows.\nStep 1: Install the COSI Controller and CRDs # COSI requires a controller and Custom Resource Definitions (CRDs) to extend Kubernetes\u0026rsquo; API for object storage operations. Install them using the official Helm chart:\nkubectl apply \\ -k \u0026#39;https://github.com/kubernetes-sigs/container-object-storage-interface//?ref=v0.2.1\u0026#39; This deploys the COSI controller and registers CRDs like BucketClass, BucketClaim, and BucketAccess.\nAlternatively, you can preview the resources before applying them:\nkubectl apply \\ --dry-run=client -o=yaml \\ -k \u0026#39;https://github.com/kubernetes-sigs/container-object-storage-interface//?ref=v0.2.1\u0026#39; Step 2: Install the COSI Driver for Linode # Providers implement COSI through drivers. Here, weâ€™ll use the Linode COSI Driver to manage Linode Object Storage buckets:\nAdd the Helm repository:\nhelm repo add linode-cosi-driver \\ https://linode.github.io/linode-cosi-driver Install the driver, substituting your Linode API token. The token must be configured with the following permissions Object Storage - Read/Write. Make sure to replace \u0026lt;your-linode-api-token\u0026gt; with your actual token:\nhelm install linode-cosi-driver \\ linode-cosi-driver/linode-cosi-driver \\ --set=apiToken=\u0026#34;\u0026lt;your-linode-api-token\u0026gt;\u0026#34; \\ --namespace=linode-cosi-driver \\ --create-namespace Step 3: Configure BucketClass and BucketAccessClass # Define a BucketClass # A BucketClass specifies storage policies. Below, we create two classesâ€”one that deletes buckets automatically and another that retains them:\n# delete-policy.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClass metadata: name: linode-objectstorage driverName: objectstorage.cosi.linode.com deletionPolicy: Delete parameters: cosi.linode.com/v1/region: us-east # retain-policy.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClass metadata: name: linode-objectstorage-retain driverName: objectstorage.cosi.linode.com deletionPolicy: Retain parameters: cosi.linode.com/v1/region: us-east Define a BucketAccessClass # A BucketAccessClass controls how applications authenticate to buckets. Here, we use API keys:\n# bucket-access-class.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketAccessClass metadata: name: linode-objectstorage driverName: objectstorage.cosi.linode.com authenticationType: Key parameters: {} Apply these manifests with kubectl apply -f \u0026lt;file\u0026gt;.yaml.\nStep 4: Deploy a Sample Application # Letâ€™s deploy an app that writes logs to a COSI-managed bucket. The deployment includes:\nA logger sidecar container that generates logs. An uploader container that syncs logs to object storage. A BucketClaim to request a bucket. A BucketAccess to manage credentials. # cosi-resources.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketAccess metadata: name: cosi-sample-app namespace: cosi-sample spec: bucketAccessClassName: linode-objectstorage bucketClaimName: cosi-sample-app credentialsSecretName: s3-credentials protocol: S3 --- apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClaim metadata: name: cosi-sample-app namespace: cosi-sample spec: bucketClassName: linode-objectstorage protocols: - S3 # cosi-sample-app.yaml apiVersion: v1 kind: Namespace metadata: name: cosi-sample --- apiVersion: apps/v1 kind: Deployment metadata: name: cosi-sample-app namespace: cosi-sample spec: selector: matchLabels: app: uploader template: metadata: labels: app: uploader spec: containers: - args: - --upload-interval=240 - --file=/mnt/logs/log.txt image: ghcr.io/anza-labs/cosi-sample-app:latest imagePullPolicy: IfNotPresent name: uploader resources: requests: cpu: 100m memory: 256Mi securityContext: readOnlyRootFilesystem: true runAsNonRoot: true volumeMounts: - mountPath: /mnt/logs name: logs - mountPath: /cosi name: cosi-secret initContainers: - args: - -c - | #!/bin/ash while true; do echo \u0026#34;$(date +\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) - Log entry\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; # Check file size and trim if needed if [ -f \u0026#34;$LOG_FILE\u0026#34; ] \u0026amp;\u0026amp; [ $(stat -c %s \u0026#34;$LOG_FILE\u0026#34;) -gt $MAX_SIZE ]; then echo \u0026#34;$(date +\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) - Rotating\u0026#34; | tee -a \u0026#34;$LOG_FILE.tmp\u0026#34; mv \u0026#34;$LOG_FILE.tmp\u0026#34; \u0026#34;$LOG_FILE\u0026#34; fi sleep 10 done command: - sh env: - name: LOG_FILE value: /mnt/logs/log.txt - name: MAX_SIZE value: \u0026#34;4194304\u0026#34; image: alpine:3.21 name: logger resources: requests: cpu: 50m memory: 64Mi restartPolicy: Always securityContext: readOnlyRootFilesystem: true runAsGroup: 1000 runAsNonRoot: true runAsUser: 1000 volumeMounts: - mountPath: /mnt/logs name: logs volumes: - name: cosi-secret secret: secretName: s3-credentials - emptyDir: {} name: logs Key Components Explained: # BucketClaim: Requests a bucket using the linode-objectstorage class. BucketAccess: References the BucketAccessClass to generate credentials stored in a s3-credentials Secret. Volumes: The cosi-secret volume mounts the credentials, while the logs volume is a temporary emptyDir for log storage. COSI vs. Manual Object Storage Management # Without COSI: # Manual Steps: Create buckets via provider UIs/CLIs, manage credentials, and hardcode them in manifests. Risk: Credentials exposed in code; no lifecycle management. With COSI: # Dynamic Provisioning: Buckets and credentials created on-demand via Kubernetes API. Automated Cleanup: Set deletionPolicy: Delete to remove unused buckets. Security: Credentials injected via Secrets, never stored in plaintext. Conclusion # COSI brings the flexibility of Kubernetes-native resource management to object storage. By defining policies through BucketClass and BucketAccessClass, teams can streamline storage operations while enforcing security and lifecycle rules. The Linode driver example demonstrates how easily COSI integrates with cloud providers, but the same principles apply to AWS S3, Google Cloud Storage, and more.\nReady to try it? Deploy the sample app and watch COSI automate the heavy lifting! ðŸš€\n","date":"6 July 2025","externalUrl":null,"permalink":"/posts/2025/0706-cosi-getting-started/","section":"Posts","summary":"Learn how to integrate the Container Object Storage Interface (COSI) with Kubernetes to automate object storage provisioning, access management, and application integration.","title":"Getting Started with COSI: Simplifying Object Storage in Kubernetes","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":" Cloud-native developer and Kubernetes evangelist driving secure, distributed systems innovations and open-source contributions.\n","date":"6 July 2025","externalUrl":null,"permalink":"/authors/shanduur/","section":"Authors","summary":"","title":"Mateusz Urbanek","type":"authors"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" RPA developer and automation specialist optimizing complex workflows with innovative process automation and data-driven insights.\n","externalUrl":null,"permalink":"/authors/niesmaczne/","section":"Authors","summary":"","title":"Nikola Borska","type":"authors"}]